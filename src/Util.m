

/*
  Return a basis of W composed of pure tensors.
 */
__find_pure_basis := function(T)  
  W := Codomain(T);
  basU := Basis(Domain(T)[2]);
  basV := Basis(Domain(T)[1]);
  
  wbas := [];
  X := sub<W | []>;
  for u in basU do 
	for v in basV do
	  w := <u,v>@T;
	  if w in X then continue; end if;
	  Append(~wbas, <u,v,w>);
	  X := sub<W | Basis(X) cat [w]>;
	  if X eq W then return wbas; end if;
	end for;
  end for;
  
  error "Tensor must be full to have a basis of codomain generated by pure tensors.";
end function;

/*
  Return the induced action on W of an isotopism on U x V.
 */
__action_on_W := function(T,phiU,phiV)
  assert IsFullyNondegenerate(T);

  W := Codomain(T);
  basU := Basis(Domain(T)[2]);
  basV := Basis(Domain(T)[1]);
  basW := __find_pure_basis(T);
  
  phiW := hom<W->W | [<b[3],<b[1]*phiU,b[2]*phiV>@T> : b in basW ]>;
  return phiW;
end function;

__vector_to_matrix := function(x,a,b)
	X := Matrix(BaseRing(x), a,a, Eltseq(x)[1..(a^2)]);
	Y := Matrix(BaseRing(x), b,b, Eltseq(x)[(a^2+1)..(a^2+b^2)]);
	return X,Y;
end function;

/*
	XA - BY = C

	A is s x b x c, 
	B is a x t x c
	C is a x b x c

 */
Adj2 := function( formsA, formsB )
//assert ( c eq #formsB ) and (c eq #formsA);
	c := #formsA;
	a := Nrows(formsB[1]);
//assert (a eq Nrows(formsB[1]));
	b := Ncols(formsA[1]);
//assert (b eq Ncols(formsA[1]));
	K := BaseRing(formsA[1]);

	s := Nrows(formsA[1]);
	t := Ncols(formsB[1]);

	A := formsA[1];
	for i in [2..c] do
		A := HorizontalJoin(A, formsA[i]);
	end for;


	
	mat := ZeroMatrix( K, a*s+t*b, a*b*c );
	for j in [1..a] do
		InsertBlock(~mat, A, s*(j-1)+1, b*c*(j-1)+1 );
	end for;

	delete A;

	slicedforms := [ [ ExtractBlock(-Transpose(B), 1, i, t, 1) : i in [1..a]] : B in formsB ];
	for i in [1..a] do
		for j in [1..c] do
			for k in [1..b] do
				InsertBlock(~mat, slicedforms[j][i], t*(k-1)+a*s+1, c*b*(i-1)+b*(j-1)+k );
			end for;
		end for;
	end for;
	delete slicedforms;

	
	return Nullspace(mat);
end function;


// useful matrix function
__vector_to_block_diagonal_matrix := function (v, degrees)
     F := BaseRing (v);
     sqdegs := [ n^2 : n in degrees ];
     assert Degree (v) eq &+ sqdegs;
     mat := MatrixAlgebra (F, degrees[1])![ v[j] : j in [1..sqdegs[1]] ];
     start := sqdegs[1];
     for i in [2..#degrees] do
         Q := [ v[ start + j ] : j in [1..sqdegs[i]] ];
         mat := DiagonalJoin (mat, MatrixAlgebra (F, degrees[i])!Q);
         start +:= sqdegs[i];
     end for;
return mat;
end function;

/*
	XA - BY = 0

	A is s x b x c, 
	B is a x t x c

 */
//TBD : fix this, it is fast.
__Adj := function( formsA, formsB )
	c := #formsA;	
assert ( c eq #formsB );

	a := Nrows(formsB[1]);
	b := Ncols(formsA[1]);
	K := BaseRing(formsA[1]);

	s := Nrows(formsA[1]);
	t := Ncols(formsB[1]);

	A := formsA[1];
	for i in [2..c] do
		A := HorizontalJoin(A, formsA[i]);
	end for;

	// echelonize the columns of A, storing the transform.
	// magma only does row-echelon (even though it only does right nullspace) grumble.
	temp := Transpose(A);
	temp, T := EchelonForm(temp);
	r := Rank(temp);
	// copy the content left over
	temp := ExtractBlock( temp, 1,1, r, Ncols(temp) );
	A := Transpose(temp);
	T := Transpose(T);
	delete temp;
		
	//mat := ZeroMatrix( K, a*s+t*b, a*b*c );
	// PENDING: it makes no sense to make this matrix, should just
	// store A and back solve iteratively.
	m1 := ZeroMatrix(K, s*a, r*a );
	for i in [1..a] do
		InsertBlock(~m1, A, s*(i-1)+1, r*(i-1)+1 );
	end for;

	delete A;

	slicedforms := [ [ ExtractBlock(-Transpose(B), 1, i, t, 1) : i in [1..a]] : B in formsB ];
	m2 := ZeroMatrix(K, t*b, r*a);
	m3 := ZeroMatrix(K, t*b, a*b*c-r*a);
	for i in [1..a] do
		// Build the block blow the A's but hit it with the echelon transform.
		Z := ZeroMatrix(K, t*b, b*c);
		for j in [1..c] do
			for k in [1..b] do
				InsertBlock(~Z, slicedforms[j][i], t*(k-1)+1, b*(j-1)+k );
			end for;
		end for;
		Z := Z*T;
		// Partition along pivot lines and shuffle into echelon form.
		Z0 := ExtractBlock( Z, 1, 1, t*b, r );
		InsertBlock(~m2, Z0, 1, r*(i-1)+1 );

		Z1 := ExtractBlock( Z, 1, r+1, t*b, b*c-r);
		InsertBlock(~m3, Z1, 1, (c*b-r)*(i-1)+1 );
	end for;
	delete slicedforms;
	
	// Now solve.
	Y := NullspaceMatrix(m3);
	rep, U := Solution( m1, -Y*m2);
	XMats := [ Matrix(K,a,s, rep+x ) : x in Basis(U) ];
	YMats := [ Matrix(K,t,b, Eltseq(Y[i]) ) : i in [1..Nrows(Y)]];
	
	Bas := [ DiagonalJoin(XMats[i],YMats[i]) : i in [1..#XMats]];
	return sub<MatrixAlgebra(K,a^2+b^2) | Bas >;

//	return X, Y;
end function;

/*
  Given systems S, T, of alternating forms,
  find space of all d x d matrices U, V such that
  U * S[i] = T[i] * V^t
  
  This seems not quite to be a module isomorphism
  problem, but it's easy enough to solve anyway.
  
  I did this using a variation of old code for
  computing bimap invariants ... there's room for 
  improvement, I'm quite sure. -PAB
*/ 
// TBD: JBW -- Josh and James have this in highly optimized form, using
// slicing and array copies.  We also have a solution using pseudo-inverses.
// Will be replaced at some point.
__Adjoint_Solve := function (S, T)
	e := #S;
	d := Nrows (S[1]);  
	F := BaseRing (Parent (S[1]));
	X := VectorSpace (F, 2 * d^2);
  mat := [];   
	for i in [1..d] do
		for j in [1..d] do
			for l in [1..e] do
				row := X!0;
				for k in [1..d] do
					row[ (i-1)*d + k ] +:= S[l][k][j];
				end for;
				for k in [1..d] do
					row[ d^2 + (j-1)*d + k ] -:= T[l][i][k];
				end for;
        Append (~mat, row);
			end for;
		end for;
	end for; 
  
  mat := Transpose (Matrix (mat));
	sol := Nullspace (mat);
	basis := [ __vector_to_block_diagonal_matrix (sol.i, [d, d]) :
					   i in [1..Ngens (sol)] ];
	MS := KMatrixSpace (F, 2*d, 2*d);
     
	return sub < MS | [ MS!b : b in basis ] >;
end function;


/* try to find a small generating set for a group U */
intrinsic ReduceGenerators (H::Grp) -> Grp
  { Redefine H on a small set of generators. }
    n := Ngens (H);
    d := 2; c := 0; NmrTrials := 10;
    while d lt n do
       L := sub < H | [ Random (H): i in [1..d] ] >;
       RandomSchreier (L);
       if #L eq #H then
          return L;
       end if;
       c +:= 1;
       if c eq NmrTrials then c := 0; d +:= 1; end if;
    end while;
return H;
end intrinsic;


